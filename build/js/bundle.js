/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/jsfft/dist/complex_array.js":
/*!**************************************************!*\
  !*** ./node_modules/jsfft/dist/complex_array.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ComplexArray = function () {\n  function ComplexArray(other) {\n    var arrayType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Float32Array;\n\n    _classCallCheck(this, ComplexArray);\n\n    if (other instanceof ComplexArray) {\n      // Copy constuctor.\n      this.ArrayType = other.ArrayType;\n      this.real = new this.ArrayType(other.real);\n      this.imag = new this.ArrayType(other.imag);\n    } else {\n      this.ArrayType = arrayType;\n      // other can be either an array or a number.\n      this.real = new this.ArrayType(other);\n      this.imag = new this.ArrayType(this.real.length);\n    }\n\n    this.length = this.real.length;\n  }\n\n  _createClass(ComplexArray, [{\n    key: 'toString',\n    value: function toString() {\n      var components = [];\n\n      this.forEach(function (value, i) {\n        components.push('(' + value.real.toFixed(2) + ', ' + value.imag.toFixed(2) + ')');\n      });\n\n      return '[' + components.join(', ') + ']';\n    }\n  }, {\n    key: 'forEach',\n    value: function forEach(iterator) {\n      var n = this.length;\n      // For gc efficiency, re-use a single object in the iterator.\n      var value = Object.seal(Object.defineProperties({}, {\n        real: { writable: true }, imag: { writable: true }\n      }));\n\n      for (var i = 0; i < n; i++) {\n        value.real = this.real[i];\n        value.imag = this.imag[i];\n        iterator(value, i, n);\n      }\n    }\n\n    // In-place mapper.\n\n  }, {\n    key: 'map',\n    value: function map(mapper) {\n      var _this = this;\n\n      this.forEach(function (value, i, n) {\n        mapper(value, i, n);\n        _this.real[i] = value.real;\n        _this.imag[i] = value.imag;\n      });\n\n      return this;\n    }\n  }, {\n    key: 'conjugate',\n    value: function conjugate() {\n      return new ComplexArray(this).map(function (value) {\n        value.imag *= -1;\n      });\n    }\n  }, {\n    key: 'magnitude',\n    value: function magnitude() {\n      var mags = new this.ArrayType(this.length);\n\n      this.forEach(function (value, i) {\n        mags[i] = Math.sqrt(value.real * value.real + value.imag * value.imag);\n      });\n\n      return mags;\n    }\n  }]);\n\n  return ComplexArray;\n}();\n\nexports.default = ComplexArray;\n\n//# sourceURL=webpack://medtechheart/./node_modules/jsfft/dist/complex_array.js?");

/***/ }),

/***/ "./node_modules/jsfft/dist/fft.js":
/*!****************************************!*\
  !*** ./node_modules/jsfft/dist/fft.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ComplexArray = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.FFT = FFT;\nexports.InvFFT = InvFFT;\nexports.frequencyMap = frequencyMap;\n\nvar _complex_array = __webpack_require__(/*! ./complex_array */ \"./node_modules/jsfft/dist/complex_array.js\");\n\nvar _complex_array2 = _interopRequireDefault(_complex_array);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n// Math constants and functions we need.\nvar PI = Math.PI;\nvar SQRT1_2 = Math.SQRT1_2;\n\nfunction FFT(input) {\n  return ensureComplexArray(input).FFT();\n};\n\nfunction InvFFT(input) {\n  return ensureComplexArray(input).InvFFT();\n};\n\nfunction frequencyMap(input, filterer) {\n  return ensureComplexArray(input).frequencyMap(filterer);\n};\n\nvar ComplexArray = exports.ComplexArray = function (_baseComplexArray) {\n  _inherits(ComplexArray, _baseComplexArray);\n\n  function ComplexArray() {\n    _classCallCheck(this, ComplexArray);\n\n    return _possibleConstructorReturn(this, (ComplexArray.__proto__ || Object.getPrototypeOf(ComplexArray)).apply(this, arguments));\n  }\n\n  _createClass(ComplexArray, [{\n    key: 'FFT',\n    value: function FFT() {\n      return fft(this, false);\n    }\n  }, {\n    key: 'InvFFT',\n    value: function InvFFT() {\n      return fft(this, true);\n    }\n\n    // Applies a frequency-space filter to input, and returns the real-space\n    // filtered input.\n    // filterer accepts freq, i, n and modifies freq.real and freq.imag.\n\n  }, {\n    key: 'frequencyMap',\n    value: function frequencyMap(filterer) {\n      return this.FFT().map(filterer).InvFFT();\n    }\n  }]);\n\n  return ComplexArray;\n}(_complex_array2.default);\n\nfunction ensureComplexArray(input) {\n  return input instanceof ComplexArray && input || new ComplexArray(input);\n}\n\nfunction fft(input, inverse) {\n  var n = input.length;\n\n  if (n & n - 1) {\n    return FFT_Recursive(input, inverse);\n  } else {\n    return FFT_2_Iterative(input, inverse);\n  }\n}\n\nfunction FFT_Recursive(input, inverse) {\n  var n = input.length;\n\n  if (n === 1) {\n    return input;\n  }\n\n  var output = new ComplexArray(n, input.ArrayType);\n\n  // Use the lowest odd factor, so we are able to use FFT_2_Iterative in the\n  // recursive transforms optimally.\n  var p = LowestOddFactor(n);\n  var m = n / p;\n  var normalisation = 1 / Math.sqrt(p);\n  var recursive_result = new ComplexArray(m, input.ArrayType);\n\n  // Loops go like O(n Î£ p_i), where p_i are the prime factors of n.\n  // for a power of a prime, p, this reduces to O(n p log_p n)\n  for (var j = 0; j < p; j++) {\n    for (var i = 0; i < m; i++) {\n      recursive_result.real[i] = input.real[i * p + j];\n      recursive_result.imag[i] = input.imag[i * p + j];\n    }\n    // Don't go deeper unless necessary to save allocs.\n    if (m > 1) {\n      recursive_result = fft(recursive_result, inverse);\n    }\n\n    var del_f_r = Math.cos(2 * PI * j / n);\n    var del_f_i = (inverse ? -1 : 1) * Math.sin(2 * PI * j / n);\n    var f_r = 1;\n    var f_i = 0;\n\n    for (var _i = 0; _i < n; _i++) {\n      var _real = recursive_result.real[_i % m];\n      var _imag = recursive_result.imag[_i % m];\n\n      output.real[_i] += f_r * _real - f_i * _imag;\n      output.imag[_i] += f_r * _imag + f_i * _real;\n\n      var _ref = [f_r * del_f_r - f_i * del_f_i, f_i = f_r * del_f_i + f_i * del_f_r];\n      f_r = _ref[0];\n      f_i = _ref[1];\n    }\n  }\n\n  // Copy back to input to match FFT_2_Iterative in-placeness\n  // TODO: faster way of making this in-place?\n  for (var _i2 = 0; _i2 < n; _i2++) {\n    input.real[_i2] = normalisation * output.real[_i2];\n    input.imag[_i2] = normalisation * output.imag[_i2];\n  }\n\n  return input;\n}\n\nfunction FFT_2_Iterative(input, inverse) {\n  var n = input.length;\n\n  var output = BitReverseComplexArray(input);\n  var output_r = output.real;\n  var output_i = output.imag;\n  // Loops go like O(n log n):\n  //   width ~ log n; i,j ~ n\n  var width = 1;\n  while (width < n) {\n    var del_f_r = Math.cos(PI / width);\n    var del_f_i = (inverse ? -1 : 1) * Math.sin(PI / width);\n    for (var i = 0; i < n / (2 * width); i++) {\n      var f_r = 1;\n      var f_i = 0;\n      for (var j = 0; j < width; j++) {\n        var l_index = 2 * i * width + j;\n        var r_index = l_index + width;\n\n        var left_r = output_r[l_index];\n        var left_i = output_i[l_index];\n        var right_r = f_r * output_r[r_index] - f_i * output_i[r_index];\n        var right_i = f_i * output_r[r_index] + f_r * output_i[r_index];\n\n        output_r[l_index] = SQRT1_2 * (left_r + right_r);\n        output_i[l_index] = SQRT1_2 * (left_i + right_i);\n        output_r[r_index] = SQRT1_2 * (left_r - right_r);\n        output_i[r_index] = SQRT1_2 * (left_i - right_i);\n\n        var _ref2 = [f_r * del_f_r - f_i * del_f_i, f_r * del_f_i + f_i * del_f_r];\n        f_r = _ref2[0];\n        f_i = _ref2[1];\n      }\n    }\n    width <<= 1;\n  }\n\n  return output;\n}\n\nfunction BitReverseIndex(index, n) {\n  var bitreversed_index = 0;\n\n  while (n > 1) {\n    bitreversed_index <<= 1;\n    bitreversed_index += index & 1;\n    index >>= 1;\n    n >>= 1;\n  }\n  return bitreversed_index;\n}\n\nfunction BitReverseComplexArray(array) {\n  var n = array.length;\n  var flips = new Set();\n\n  for (var i = 0; i < n; i++) {\n    var r_i = BitReverseIndex(i, n);\n\n    if (flips.has(i)) continue;\n\n    var _ref3 = [array.real[r_i], array.real[i]];\n    array.real[i] = _ref3[0];\n    array.real[r_i] = _ref3[1];\n    var _ref4 = [array.imag[r_i], array.imag[i]];\n    array.imag[i] = _ref4[0];\n    array.imag[r_i] = _ref4[1];\n\n\n    flips.add(r_i);\n  }\n\n  return array;\n}\n\nfunction LowestOddFactor(n) {\n  var sqrt_n = Math.sqrt(n);\n  var factor = 3;\n\n  while (factor <= sqrt_n) {\n    if (n % factor === 0) return factor;\n    factor += 2;\n  }\n  return n;\n}\n\n//# sourceURL=webpack://medtechheart/./node_modules/jsfft/dist/fft.js?");

/***/ }),

/***/ "./ts/kiwrious/service/serial/HeartRateProcessor.ts":
/*!**********************************************************!*\
  !*** ./ts/kiwrious/service/serial/HeartRateProcessor.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HEART_RATE_RESULT_STATUS\": () => (/* binding */ HEART_RATE_RESULT_STATUS),\n/* harmony export */   \"HeartRateProcessor\": () => (/* binding */ HeartRateProcessor)\n/* harmony export */ });\nconst fft = __webpack_require__(/*! jsfft */ \"./node_modules/jsfft/dist/fft.js\");\nconst MIN_INPUT_VALUE = 300000;\nconst MAX_INPUT_VALUE = 900000;\nconst SAMPLE_RATE = 200;\nconst INPUT_ARRAY_SIZE = 2048;\nconst RESULT_ARRAY_SIZE = 100;\nconst SOS = [\n    [[1.0000, 0, -1.0000], [1.0000, -1.9794, 0.9847]],\n    [[1.0000, 0, -1.0000], [1.0000, -1.9948, 0.9953]],\n    [[1.0000, 0, -1.0000], [1.0000, -1.9537, 0.9583]],\n    [[1.0000, 0, -1.0000], [1.0000, -1.9849, 0.9855]],\n    [[1.0000, 0, -1.0000], [1.0000, -1.9730, 0.9737]],\n    [[1.0000, 0, -1.0000], [1.0000, -1.9392, 0.9426]],\n    [[1.0000, 0, -1.0000], [1.0000, -1.9571, 0.9583]],\n    [[1.0000, 0, -1.0000], [1.0000, -1.9410, 0.9432]]\n];\nconst GAIN = [0.0256, 0.0256, 0.0254, 0.0254, 0.0252, 0.0252, 0.0251, 0.0251, 1.0000];\nconst HEART_RATE_RESULT_STATUS = {\n    TOO_LOW: 'TOO_LOW',\n    TOO_HIGH: 'TOO_HIGH',\n    PROCESSING: 'PROCESSING',\n    READY: 'READY',\n};\nclass FixedArray {\n    constructor(size) {\n        this._size = size;\n        this._array = [];\n        this._sum = 0;\n    }\n    _log(...msg) {\n        console.log('|FixedArray|', ...msg);\n    }\n    get isAverageReady() {\n        return this._array.length >= this._size;\n    }\n    get average() {\n        return FixedArray.calcAverage(this._sum, this._array.length);\n    }\n    get array() {\n        return this._array;\n    }\n    _cleanup() {\n        while (this._array.length > this._size) {\n            const removed = this._array.shift();\n            if (removed) {\n                // this._log('removed..', removed);\n                this._sum -= removed;\n            }\n        }\n    }\n    _add(item) {\n        //this._log('add..', item);\n        this._array.push(item);\n        this._sum += item;\n    }\n    add(item) {\n        this._add(item);\n        this._cleanup();\n    }\n    addItems(items) {\n        for (const i of items) {\n            this._add(i);\n        }\n        this._cleanup();\n    }\n    static calcSum(array) {\n        return array.reduce((item, curr) => item + curr, 0);\n    }\n    static calcAverage(sum, length) {\n        if (!length) {\n            return 0;\n        }\n        return sum / length;\n    }\n    static createSteppedArray(startValue, stopValue, cardinality) {\n        const arr = [];\n        const step = (stopValue - startValue) / (cardinality - 1);\n        for (let i = 0; i < cardinality; i++) {\n            arr.push(startValue + (step * i));\n        }\n        return arr;\n    }\n}\n// Biquad filter object\nclass Biquad {\n    // Biquad direct form II representation, g1 and g2 are input and output gains respectively\n    constructor(b, a, g1, g2) {\n        this.b = b;\n        this.a = a;\n        this.g1 = g1;\n        this.g2 = g2;\n        this.w = [1, 1, 1];\n    }\n    _log(...msg) {\n        console.log('|Biquad|', ...msg);\n    }\n    updateFilter(x) {\n        const xGained = x * this.g1;\n        this.w[2] = this.w[1];\n        this.w[1] = this.w[0];\n        this.w[0] = xGained - this.a[1] * this.w[1] - this.a[2] * this.w[2];\n        const y = this.b[0] * this.w[0] + this.b[1] * this.w[1] + this.b[2] * this.w[2];\n        const yGained = y * this.g2;\n        return yGained;\n    }\n}\nclass HeartRateProcessor {\n    constructor() {\n        this._log('ctor');\n        this._initFilters();\n        const halfSampleRate = Math.floor(SAMPLE_RATE / 2);\n        this._resultArray = new FixedArray(RESULT_ARRAY_SIZE);\n        this._inputArray = new FixedArray(INPUT_ARRAY_SIZE);\n        const L = INPUT_ARRAY_SIZE;\n        const halfL = Math.floor(L / 2);\n        this._xf = FixedArray.createSteppedArray(0, halfSampleRate, halfL);\n    }\n    _log(...msg) {\n        console.log('|HeartRateProcessor|', ...msg);\n    }\n    _initFilters() {\n        this._filters = SOS.map((s, i) => new Biquad(s[0], s[1], GAIN[i], 1));\n    }\n    getStatusForInput(input) {\n        if (input < MIN_INPUT_VALUE) {\n            return HEART_RATE_RESULT_STATUS.TOO_LOW;\n        }\n        else if (input > MAX_INPUT_VALUE) {\n            return HEART_RATE_RESULT_STATUS.TOO_HIGH;\n        }\n        return HEART_RATE_RESULT_STATUS.PROCESSING;\n    }\n    processSingleInput(input) {\n        const status = this.getStatusForInput(input);\n        if (status !== HEART_RATE_RESULT_STATUS.PROCESSING) {\n            // this._log('invalid value range');\n            const result = { status };\n            return result;\n        }\n        this._inputArray.add(input);\n        const output = this.process();\n        if (!output) {\n            const result = { status: HEART_RATE_RESULT_STATUS.PROCESSING };\n            return result;\n        }\n        const result = { status: HEART_RATE_RESULT_STATUS.READY, value: output };\n        return result;\n    }\n    processMultiInput(inputArray) {\n        for (const input of inputArray) {\n            const status = this.getStatusForInput(input);\n            if (status !== HEART_RATE_RESULT_STATUS.PROCESSING) {\n                // this._log('invalid value range');\n                const result = { status };\n                return result;\n            }\n        }\n        this._inputArray.addItems(inputArray);\n        const output = this.process();\n        if (!output) {\n            const result = { status: HEART_RATE_RESULT_STATUS.PROCESSING };\n            return result;\n        }\n        const result = { status: HEART_RATE_RESULT_STATUS.READY, value: output };\n        return result;\n    }\n    process() {\n        if (!this._inputArray.isAverageReady) {\n            //this._log('waiting for enough input', this._inputArray.array.length);\n            return null;\n        }\n        const heartRate = this._process(this._inputArray);\n        if (!heartRate) {\n            return null;\n        }\n        this._resultArray.add(heartRate);\n        if (!this._resultArray.isAverageReady) {\n            //this._log('waiting for enough results', this._resultArray.array.length);\n            return null;\n        }\n        return this._resultArray.average;\n    }\n    _process(inputArray) {\n        if (!inputArray.isAverageReady) {\n            throw new Error(`average is not ready. arr len: ${inputArray.array.length}`);\n        }\n        const filtered = inputArray.array.map((value) => {\n            const adjustedV = value - inputArray.average;\n            return this._updateAllFilters(adjustedV);\n        });\n        const dataFFT = new fft.ComplexArray(filtered.length).map((value, i, n) => {\n            value.real = filtered[i];\n        });\n        const spectrum = dataFFT.FFT();\n        const mag = spectrum.magnitude();\n        let minVal = 0;\n        let minIndex = 0;\n        for (let index = 0; index < mag.length / 2; index++) {\n            const element = mag[index];\n            if (element > minVal) {\n                minVal = element;\n                minIndex = index;\n            }\n        }\n        const heartRate = this._xf[minIndex] * 60;\n        return heartRate;\n    }\n    _updateAllFilters(input) {\n        let output;\n        let current = input;\n        for (let f of this._filters) {\n            output = f.updateFilter(current);\n            current = output;\n        }\n        return output;\n    }\n}\n\n\n//# sourceURL=webpack://medtechheart/./ts/kiwrious/service/serial/HeartRateProcessor.ts?");

/***/ }),

/***/ "./ts/kiwrious/service/serial/SerialDecoder.ts":
/*!*****************************************************!*\
  !*** ./ts/kiwrious/service/serial/SerialDecoder.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SerialDecoder\": () => (/* binding */ SerialDecoder)\n/* harmony export */ });\nclass SerialDecoder {\n    constructor() {\n    }\n    _log(...msg) {\n        console.log('|SerialDecoder|', ...msg);\n    }\n    _err(...msg) {\n        console.error(\"|SerialDecoder|\", ...msg);\n    }\n}\n\n\n//# sourceURL=webpack://medtechheart/./ts/kiwrious/service/serial/SerialDecoder.ts?");

/***/ }),

/***/ "./ts/kiwrious/service/serial/SerialHeartRateDecoder.ts":
/*!**************************************************************!*\
  !*** ./ts/kiwrious/service/serial/SerialHeartRateDecoder.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SerialHeartRateDecoder\": () => (/* binding */ SerialHeartRateDecoder)\n/* harmony export */ });\n/* harmony import */ var _HeartRateProcessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HeartRateProcessor */ \"./ts/kiwrious/service/serial/HeartRateProcessor.ts\");\n/* harmony import */ var _SerialDecoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SerialDecoder */ \"./ts/kiwrious/service/serial/SerialDecoder.ts\");\n/* harmony import */ var _SerialRawValue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SerialRawValue */ \"./ts/kiwrious/service/serial/SerialRawValue.ts\");\n/* harmony import */ var _SerialUtil__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SerialUtil */ \"./ts/kiwrious/service/serial/SerialUtil.ts\");\n\n\n\n\nclass SerialHeartRateDecoder extends _SerialDecoder__WEBPACK_IMPORTED_MODULE_1__.SerialDecoder {\n    constructor() {\n        super();\n        this._processor = new _HeartRateProcessor__WEBPACK_IMPORTED_MODULE_0__.HeartRateProcessor();\n        // Detector\n        this._detector = new HeartRateDetector();\n    }\n    _log(...msg) {\n        console.log(\"|SerialHeartRateDecoder|\", ...msg);\n    }\n    async decode(array) {\n        // this._log('headers-footers', rawValue.header2Bytes, rawValue.footer2Bytes);\n        const subArrays = array.map((i) => i.rawValue.subarray(6, 22));\n        // this._log('subArrays', subArrays);\n        const rawData = _SerialUtil__WEBPACK_IMPORTED_MODULE_3__.SerialUtil.concatMultiArrays(subArrays);\n        // this._log('rawData', rawData);\n        console.log(this._detector);\n        const heartRateResult = await this._detector.detectHeartRate(rawData);\n        this._log(\"heartrate-result\", heartRateResult);\n        const value0 = {\n            label: _SerialRawValue__WEBPACK_IMPORTED_MODULE_2__.SENSOR_VALUE.HEART_RATE,\n            value: heartRateResult,\n            type: \"object\",\n        };\n        const result = {\n            sensorType: array[0].sensorType,\n            decodedValues: [value0],\n        };\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack://medtechheart/./ts/kiwrious/service/serial/SerialHeartRateDecoder.ts?");

/***/ }),

/***/ "./ts/kiwrious/service/serial/SerialHexValue.ts":
/*!******************************************************!*\
  !*** ./ts/kiwrious/service/serial/SerialHexValue.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SerialHexValue\": () => (/* binding */ SerialHexValue),\n/* harmony export */   \"SerialNumberValue\": () => (/* binding */ SerialNumberValue)\n/* harmony export */ });\nclass SerialHexValue {\n    constructor(rawHexValue) {\n        this.rawHexValue = rawHexValue;\n    }\n    toFloat() {\n        const raw = Number(this.rawHexValue);\n        const s = raw & 0x80000000 ? -1 : 1;\n        const e = ((raw >> 23) & 0xff) - 127;\n        const c = 1 + (raw & 0x7fffff) / 0x7fffff;\n        return s * c * Math.pow(2, e);\n    }\n    toInt() {\n        return Number((parseInt(this.rawHexValue)).toFixed());\n    }\n    divideByHundred() {\n        return Number((parseInt(this.rawHexValue) / 100).toFixed());\n    }\n}\nclass SerialNumberValue {\n    constructor(value) {\n        this._raw = value;\n    }\n    get value() {\n        return this._raw;\n    }\n    toInt() {\n        return Number(this._raw.toFixed());\n    }\n    divideByHundred() {\n        return Number((this._raw / 100).toFixed());\n    }\n}\n\n\n//# sourceURL=webpack://medtechheart/./ts/kiwrious/service/serial/SerialHexValue.ts?");

/***/ }),

/***/ "./ts/kiwrious/service/serial/SerialRawValue.ts":
/*!******************************************************!*\
  !*** ./ts/kiwrious/service/serial/SerialRawValue.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SENSOR_TYPE\": () => (/* binding */ SENSOR_TYPE),\n/* harmony export */   \"SENSOR_VALUE\": () => (/* binding */ SENSOR_VALUE),\n/* harmony export */   \"SerialRawValue\": () => (/* binding */ SerialRawValue)\n/* harmony export */ });\n/* harmony import */ var _SerialHexValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SerialHexValue */ \"./ts/kiwrious/service/serial/SerialHexValue.ts\");\n\nconst SENSOR_TYPE = {\n    UNKNOWN: 'UNKNOWN',\n    UV: 'UV',\n    HUMIDITY: 'HUMIDITY',\n    VOC: 'VOC',\n    CONDUCTIVITY: 'CONDUCTIVITY',\n    HEART_RATE: 'HEART_RATE',\n    TEMPERATURE: 'TEMPERATURE',\n    TEMPERATURE2: 'TEMPERATURE2',\n    // TODO: other sensor types\n};\nconst SENSOR_VALUE = {\n    UNKNOWN: 'UNKNOWN',\n    UV_INDEX: 'Uv',\n    LUX: 'Lux',\n    HUMIDITY: 'Hum',\n    TEMPERATURE: 'Temp',\n    VOC: 'Voc',\n    CONDUCTIVITY: 'Con',\n    HEART_RATE: 'HeartRate',\n    INFRARED_TEMPERATURE: 'InfraredTemp',\n    AMBIENT_TEMPERATURE: 'AmbientTemp',\n};\nclass SerialRawValue {\n    constructor(rawValue) {\n        this.rawValue = rawValue;\n        this.dataView = new DataView(rawValue.buffer);\n        if (!this.isValidLength) {\n            throw new Error(`invalid array length. expected [] but got [${rawValue.length}]`);\n        }\n    }\n    get isValidLength() {\n        return this.rawValue.length === 26;\n    }\n    get sensorTypeRaw() {\n        return this.rawValue[2];\n    }\n    get header2Bytes() {\n        return this.getTwoBytesByIndex(0);\n    }\n    get sequence2Bytes() {\n        return this.getTwoBytesByIndex(22);\n    }\n    get footer2Bytes() {\n        return this.getTwoBytesByIndex(24);\n    }\n    get sensorType() {\n        switch (this.sensorTypeRaw) {\n            case 10: return SENSOR_TYPE.HEART_RATE;\n            // TODO OTHER SENSORS\n            default:\n                throw new Error(`invalid sensor type ${this.sensorTypeRaw}`);\n        }\n    }\n    // For humidity and temp sensor\n    getTwoBytesSignedByIndex(index) {\n        const value = this.dataView.getInt16(index, true);\n        return value;\n    }\n    getTwoBytesUnsignedByIndex(index) {\n        const value = this.dataView.getUint16(index, true);\n        return value;\n    }\n    getTwoBytesByIndex(index) {\n        const value = this.dataView.getUint16(index, true);\n        return value;\n    }\n    getFourBytesByIndex(index) {\n        const value = this.dataView.getUint32(index, true);\n        return value;\n    }\n    getFourBytesFloatByIndex(index) {\n        const value = this.dataView.getFloat32(index, true);\n        return value;\n    }\n    sliceBytes(index, numberOfBytes) {\n        if (index + numberOfBytes > this.rawValue.length) {\n            throw new Error(`invalid index [${index}] for array length [${this.rawValue.length}]`);\n        }\n        const sliced = this.rawValue.slice(index, index + numberOfBytes);\n        return sliced;\n    }\n    getByteByIndex(index) {\n        if (index >= this.rawValue.length) {\n            throw new Error(`invalid index [${index}] for array length [${this.rawValue.length}]`);\n        }\n        const value = this.rawValue[index];\n        return value;\n    }\n    getHexDigitByIndex(index) {\n        if (index >= this.rawValue.length) {\n            throw new Error(`invalid index [${index}] for array length [${this.rawValue.length}]`);\n        }\n        const value16 = this.rawValue[index]\n            .toString(16)\n            .padStart(2, '0');\n        return value16;\n    }\n    // obsolete, use getTwoBytesByIndex() istead\n    // TODO: refactor to use getTwoBytesByIndex()\n    getHexString2(index0, index1) {\n        const data0_a = this.getHexDigitByIndex(index0);\n        const data0_b = this.getHexDigitByIndex(index1);\n        const data0 = `0x${data0_a}${data0_b}`;\n        return new _SerialHexValue__WEBPACK_IMPORTED_MODULE_0__.SerialHexValue(data0);\n    }\n    // obsolete, use getFourBytesByIndex() istead\n    // TODO: refactor to use getFourBytesByIndex()\n    getHexString4(index0, index1, index2, index3) {\n        const data0_a = this.getHexDigitByIndex(index0);\n        const data0_b = this.getHexDigitByIndex(index1);\n        const data0_c = this.getHexDigitByIndex(index2);\n        const data0_d = this.getHexDigitByIndex(index3);\n        const data0 = `0x${data0_a}${data0_b}${data0_c}${data0_d}`;\n        return new _SerialHexValue__WEBPACK_IMPORTED_MODULE_0__.SerialHexValue(data0);\n    }\n}\n\n\n//# sourceURL=webpack://medtechheart/./ts/kiwrious/service/serial/SerialRawValue.ts?");

/***/ }),

/***/ "./ts/kiwrious/service/serial/SerialReader.ts":
/*!****************************************************!*\
  !*** ./ts/kiwrious/service/serial/SerialReader.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SerialReader\": () => (/* binding */ SerialReader)\n/* harmony export */ });\n/* harmony import */ var _SerialRawValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SerialRawValue */ \"./ts/kiwrious/service/serial/SerialRawValue.ts\");\n/* harmony import */ var _SerialUtil__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SerialUtil */ \"./ts/kiwrious/service/serial/SerialUtil.ts\");\n\n\nconst EXPECTED_ARRAY_SIZE = 26;\nclass SerialReader {\n    constructor(reader) {\n        this._reader = reader;\n        this._array = new Uint8Array();\n    }\n    _log(...msg) {\n        console.log('|SerialReader|', ...msg);\n    }\n    _err(...msg) {\n        console.error('|SerialReader|', ...msg);\n    }\n    async _read() {\n        //If we have enough in the array use that don't read...\n        if (this._array.length >= EXPECTED_ARRAY_SIZE) {\n            const spliced = this._array.subarray(0, EXPECTED_ARRAY_SIZE);\n            this._array = this._array.subarray(EXPECTED_ARRAY_SIZE);\n            //this._log('reading from array..', this._array.length, spliced.length);\n            return new _SerialRawValue__WEBPACK_IMPORTED_MODULE_0__.SerialRawValue(spliced);\n        }\n        if (!this._reader) {\n            this._err('readLoop - no reader. returning');\n            throw new Error('no reader');\n        }\n        //read data from reader\n        const readInstance = await this._reader.read();\n        const { value, done } = readInstance;\n        if (done) {\n            //this._log(\"[readOnce] DONE\", done);\n            throw new Error('reader done');\n        }\n        //this._log('reading length', value.length);\n        // if match expectation, clear buffer and return..\n        if (value.length === EXPECTED_ARRAY_SIZE) {\n            //this._log('array length matched. clearing temp array..');\n            this._array = new Uint8Array();\n            return new _SerialRawValue__WEBPACK_IMPORTED_MODULE_0__.SerialRawValue(value.subarray(0));\n        }\n        //otherwise, append to array\n        this._array = _SerialUtil__WEBPACK_IMPORTED_MODULE_1__.SerialUtil.concatArray(this._array, value);\n        //this._log('added to array. length:', this._array.length);\n        //then read again (recursive)\n        return await this.readOnce();\n    }\n    async readMultiple(numberToRead = 10) {\n        const array = [];\n        while (array.length < numberToRead) {\n            // this._log('reading..')\n            const value = await this._read();\n            array.push(value);\n        }\n        return array;\n    }\n    async readOnce() {\n        const value = await this._read();\n        // if (value) {\n        //   this._log('reading meta', value.header2Bytes, value.footer2Bytes, value.rawValue.length, value.sensorTypeRaw);\n        // }\n        return value;\n    }\n}\n\n\n//# sourceURL=webpack://medtechheart/./ts/kiwrious/service/serial/SerialReader.ts?");

/***/ }),

/***/ "./ts/kiwrious/service/serial/SerialService.ts":
/*!*****************************************************!*\
  !*** ./ts/kiwrious/service/serial/SerialService.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _SerialReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SerialReader */ \"./ts/kiwrious/service/serial/SerialReader.ts\");\n/* harmony import */ var _SerialHeartRateDecoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SerialHeartRateDecoder */ \"./ts/kiwrious/service/serial/SerialHeartRateDecoder.ts\");\n\n\nclass SerialService {\n    constructor() {\n        this._isConnected = false;\n        this._isReading = false;\n        this._log('ctor');\n    }\n    _log(...msg) {\n        console.log('|SerialService|', ...msg);\n    }\n    _err(...msg) {\n        console.error(\"|SerialService|\", ...msg);\n    }\n    get isReading() {\n        return this._isReading;\n    }\n    get canResumeReading() {\n        // if the port is not null then we probably can resume\n        return !!this._port;\n    }\n    triggerStopReading() {\n        // This will cause to exit the reading loop gracefuly\n        this._isReading = false;\n    }\n    closeReader() {\n        this._log('closing reader..');\n        if (!this._reader) {\n            this._log('no reader found. exiting..');\n            return;\n        }\n        this.triggerStopReading();\n        this._log('cancelling..');\n        this._reader.cancel();\n        this._log('releasing lock..');\n        this._reader.releaseLock();\n        this._reader = null;\n        this._log('reader closed');\n    }\n    async closePortAsync() {\n        this._log('closing port..');\n        if (!this._port) {\n            this._log('no port found. exiting..');\n            return;\n        }\n        this._isConnected = false;\n        try {\n            await this._port.close();\n            this._log('port closed');\n        }\n        catch (e) {\n            this._err('failed to close port', e);\n        }\n        // DO NOT UNCOMMECNT THE NEXT LINE. We keep a reference to the port so we can reuse it later\n        // this.port = null;\n        if (this.onSerialConnection) {\n            this.onSerialConnection(this._isConnected);\n        }\n    }\n    async resumeReading() {\n        this._log('resume reading..');\n        if (!this._port) {\n            this._log('port not found, restarting..');\n            await this.connectAndReadAsync();\n            return;\n        }\n        return await this.startStage2ConnectPortAsync(this._port);\n    }\n    async disconnectAsync() {\n        this._log('disconnecting..');\n        this.triggerStopReading();\n        setTimeout(async () => {\n            await this.stopStage2ClosePortAsync();\n        }, 0);\n    }\n    async connectAndReadAsync() {\n        this._log('connect and read..');\n        const port = await this.startStage1RequestPortAsync();\n        if (!port) {\n            this._err('unable to request port');\n            return;\n        }\n        return await this.startStage2ConnectPortAsync(port);\n    }\n    async startStage1RequestPortAsync() {\n        const { serial } = navigator;\n        if (!serial) {\n            alert(\"This feature only works on Chrome with 'Experimental Web Platform features' enabled\");\n            return null;\n        }\n        serial.onconnect = () => {\n            this._log('serial connect');\n        };\n        serial.ondisconnect = async () => {\n            this._log('serial disconnect');\n            await this.disconnectAsync();\n            this._port = null;\n        };\n        this._log('requesting port..');\n        const port = await serial\n            .requestPort({\n            filters: [{ usbVendorId: 0x04d8, vendorId: 0x04d8 }, { usbVendorId: 0x0d28, usbProductId: 0x0204 }],\n        })\n            .catch((e) => {\n            this._err(`failed to serial.requestPort`, e);\n        });\n        if (!port) {\n            this._err(\"unable to find port value\");\n            return null;\n        }\n        return port;\n    }\n    async startStage2ConnectPortAsync(port) {\n        this._log('startStage2ReadingAsync');\n        const connection = await this.connectPortAsync(port);\n        if (!connection) {\n            this._err('failed to connect');\n            return;\n        }\n        this._isConnected = true;\n        this._port = connection.port;\n        this._reader = connection.reader;\n        if (this.onSerialConnection) {\n            this.onSerialConnection(this._isConnected);\n        }\n        this.startReading();\n    }\n    async stopStage2ClosePortAsync() {\n        this._log('stopStage2ClosePortAsync');\n        this.closeReader();\n        await this.closePortAsync();\n    }\n    //TODO: PORT ANY\n    async connectPortAsync(port) {\n        const portInfo = port.getInfo();\n        this._log('port info', portInfo);\n        if (port.readable) {\n            this._err(\"port is already readable\");\n            return null;\n        }\n        this._log('openning port..');\n        await port\n            .open({ baudrate: 230400, baudRate: 230400 })\n            .catch((e) => {\n            this._err(`failed to port.open`, e);\n        });\n        if (!port.readable) {\n            this._err(`port is not readable..`);\n            return null;\n        }\n        const reader = port.readable.getReader();\n        if (reader.locked) {\n            this._err(\"reader is locked\");\n            return null;\n        }\n        return { port, reader };\n    }\n    async startReading() {\n        try {\n            this._log('starting reader..');\n            const serialReader = new _SerialReader__WEBPACK_IMPORTED_MODULE_0__.SerialReader(this._reader);\n            this._log('creating decoder..');\n            const decoder = new _SerialHeartRateDecoder__WEBPACK_IMPORTED_MODULE_1__.SerialHeartRateDecoder();\n            this._log('starting loop..');\n            this._isReading = true;\n            while (this._isReading) {\n                const serialValues = await serialReader.readMultiple(10);\n                const decodedValues = await decoder.decode(serialValues);\n                if (decodedValues) {\n                    if (this.onSerialData) {\n                        this.onSerialData(decodedValues);\n                    }\n                }\n            }\n            this._log('loop complete..');\n        }\n        catch (e) {\n            this._err('error reading loop startReading', e);\n        }\n        finally {\n            this.stopStage2ClosePortAsync();\n            this._log('startReading complete');\n        }\n    }\n}\nconst singletonInstance = new SerialService();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (singletonInstance);\n\n\n//# sourceURL=webpack://medtechheart/./ts/kiwrious/service/serial/SerialService.ts?");

/***/ }),

/***/ "./ts/kiwrious/service/serial/SerialUtil.ts":
/*!**************************************************!*\
  !*** ./ts/kiwrious/service/serial/SerialUtil.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SerialUtil\": () => (/* binding */ SerialUtil)\n/* harmony export */ });\nclass SerialUtil {\n    static concatArray(a, b) {\n        const c = new Uint8Array(a.length + b.length);\n        c.set(a, 0);\n        c.set(b, a.length);\n        return c;\n    }\n    static concatMultiArrays(arrays) {\n        const totalLen = arrays.reduce((a, c) => {\n            return a + c.length;\n        }, 0);\n        const result = new Uint8Array(totalLen);\n        arrays.reduce((a, c) => {\n            result.set(c, a);\n            return a + c.length;\n        }, 0);\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack://medtechheart/./ts/kiwrious/service/serial/SerialUtil.ts?");

/***/ }),

/***/ "./ts/main.ts":
/*!********************!*\
  !*** ./ts/main.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _kiwrious_service_serial_SerialService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./kiwrious/service/serial/SerialService */ \"./ts/kiwrious/service/serial/SerialService.ts\");\n\nconst zincRenderer = window.zincRenderer;\nconst speedSlider = document.getElementById(\"speed_slider\");\nconst MAX_ZINC_VALUE = 8000;\nconst MAX_HEARTRATE_VALUE = 160;\nconst $connect = document.getElementById(\"btn-kiwrious-connect\");\nconst $disconnect = document.getElementById(\"btn-kiwrious-disconnect\");\n_kiwrious_service_serial_SerialService__WEBPACK_IMPORTED_MODULE_0__.default.onSerialConnection = (isConnected) => {\n    console.log(isConnected);\n    $connect.style.display = isConnected ? \"none\" : \"block\";\n    $disconnect.style.display = isConnected ? \"block\" : \"none\";\n};\n$connect.onclick = async () => {\n    $connect.disabled = true;\n    await _kiwrious_service_serial_SerialService__WEBPACK_IMPORTED_MODULE_0__.default.connectAndReadAsync();\n    $connect.disabled = false;\n};\n$disconnect.onclick = async () => {\n    $disconnect.disabled = true;\n    await _kiwrious_service_serial_SerialService__WEBPACK_IMPORTED_MODULE_0__.default.disconnectAsync();\n    $disconnect.disabled = false;\n};\n$disconnect.style.display = \"none\";\nconst $kiwriousValue = document.getElementById(\"kiwrious-value\");\nconst convertToZincValue = (heartRateValue) => {\n    return (MAX_ZINC_VALUE * heartRateValue) / MAX_HEARTRATE_VALUE;\n};\n_kiwrious_service_serial_SerialService__WEBPACK_IMPORTED_MODULE_0__.default.onSerialData = (decodedData) => {\n    const values = decodedData.decodedValues;\n    const val = values[0].value;\n    const status = val.status;\n    const hrVal = val.heartrate;\n    $kiwriousValue.innerText = status;\n    if (status === \"Ready\") {\n        $kiwriousValue.innerText = hrVal.toString();\n        //   const zincValue = convertToZincValue(hrVal);\n        //   zincRenderer.setPlayRate(zincValue);\n        //   speedSlider.value = String(zincValue);\n    }\n};\n\n\n//# sourceURL=webpack://medtechheart/./ts/main.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./ts/main.ts");
/******/ 	
/******/ })()
;